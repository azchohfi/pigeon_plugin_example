// Autogenerated from Pigeon (v1.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/standard_message_codec.h>
#include <map>
#include <string>
#include "messages.h"



/** Generated class from Pigeon. */


  std::string Version::getString() { return string; }
  void Version::setString(std::string setterArg) { this->string = setterArg; }

  flutter::EncodableMap Version::ToEncodableMap() {
    flutter::EncodableMap toMapResult;
    toMapResult.insert(std::make_pair(flutter::EncodableValue("string"), flutter::EncodableValue(string)));
    return toMapResult;
  }
  Version::Version() {}
  Version::Version(flutter::EncodableMap map) {
    auto encodablestring = map.at(flutter::EncodableValue("string"));
    if(const std::string* pvalstring = std::get_if<std::string>(&encodablestring)) string = *pvalstring;
  }

ExampleApiCodecSerializer::ExampleApiCodecSerializer() {}
flutter::EncodableValue ExampleApiCodecSerializer::ReadValueOfType(uint8_t type, flutter::ByteStreamReader* stream) const{
  switch (type) {
    case 128:     
      return flutter::CustomEncodableValue(Version(std::get<flutter::EncodableMap>(ReadValue(stream))));
    
    default:    
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
    
  }
}
void ExampleApiCodecSerializer::WriteValue(const flutter::EncodableValue& value, flutter::ByteStreamWriter* stream) const{
  if(const flutter::CustomEncodableValue* customValue = std::get_if<flutter::CustomEncodableValue>(&value)){
    if(customValue->type() == typeid(Version)){
      stream->WriteByte(128);
      WriteValue(std::any_cast<Version>(*customValue).ToEncodableMap(), stream);
    } else 
{
      flutter::StandardCodecSerializer::WriteValue(value, stream);
    }
  } else 
{
    flutter::StandardCodecSerializer::WriteValue(value, stream);
  }
}

/** The codec used by ExampleApi. */
const flutter::StandardMessageCodec& ExampleApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&ExampleApiCodecSerializer::Instance());
}

/** Sets up an instance of `ExampleApi` to handle messages through the `binaryMessenger`. */
void ExampleApi::Setup(flutter::BinaryMessenger* binaryMessenger, ExampleApi* api) {
  {
    auto channel = std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
        binaryMessenger, "dev.flutter.pigeon.ExampleApi.getPlatformVersion", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const auto& message, auto reply){
        auto wrapped = flutter::EncodableMap();
        try {
          Version output = api->getPlatformVersion();
          wrapped.insert(std::make_pair(flutter::EncodableValue("result"), flutter::CustomEncodableValue(output)));
        }
        catch (std::exception exception){
          wrapped.insert(std::make_pair(flutter::EncodableValue("error"), WrapError(exception)));
        }
        reply(wrapped);
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}
flutter::EncodableMap ExampleApi::WrapError(std::exception exception) {
  return flutter::EncodableMap({
    {flutter::EncodableValue("message"), flutter::EncodableValue(exception.what())},
    {flutter::EncodableValue("code"), flutter::EncodableValue("Error")},
    {flutter::EncodableValue("details"), flutter::EncodableValue()}
  });
}
